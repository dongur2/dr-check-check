# 03 프로세스와 스레드

## 프로세스
프로그램이 프로세스가 되기 위해서는,  **메모리에 올라오는 것**과 동시에 **프로세스 제어 블록(PCB)** 이 생성되어야 한다. 이 때 PCB는 **PID, 메모리 관련 정보, 프로세스가 사용하는 각종 중간값**을 포함한다.

![title](https://thebook.io/img/080367/028.jpg)

- 생성 상태: 프로세스가 메모리에 올라와  PCB가 생성되어 실행 준비를 완료
- 준비 상태: 프로세스가 CPU를 얻을 때까지 기다리는 상태
- 실행 상태: 프로세스가 실제로 CPU를 얻어 실제 작업을 수행 - 주어진 시간 내에 작업을 끝내지 못하면 준비 상태로 이동
- 대기 상태: 입출력이 발생할 경우, 완료될 때까지 기다리는 상태 - 완료되면 준비 상태로 이동
- 종료 상태: 프로세스가 주어진 시간 내 작업을 완료 ->  PCB 폐기

<details>
<summary>문맥 교환</summary>
<div markdown="1">

<u>CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업</u>으로, **실행 상태에서 나가는 PCB에는 지금까지의 작업 내용을 저장 & 실행 상태로 들어오는 PCB의 내용으로 CPU를 재설정하는 작업**을 말한다.

: 타임 슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 시간으로 설정

</div>
</details>

#### 프로세스의 구조
![title](https://velog.velcdn.com/images/phc09188/post/55e9953f-e3ea-4b10-b6be-fec7a82f943e/image.png)   
작성한 프로그램의 본문이 기술된 **코드 영역** + 코드가 실행되면서 사용하는 변수/파일 등 각종 데이터가 모인 **데이터 영역** + 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 **스택 영역**

### `fork()` System Call : 실행 중인 프로세스와 똑같은 프로세스를 복사
이 때, 기존 프로세스는 **부모 프로세스**, 새로 생성된 프로세스는 **자식 프로세스**가 된다. 자식 프로세스의 PCB는 생성되면서 **PID, 메모리 관련 정보, PPID, CPID**가 변경된다.

프로세스를 새로 생성하지 않고 복사함으로써 **빠른 생성 속도, 추가 작업 없는 부모 프로세스로부터의 자원 상속, 종료된 자식 프로세스의 자원을 부모 프로세스가 정리할 수 있어 효율적인 시스템 관리**라는 장점을 누릴 수 있다.

### `exec()` System Call: 기존 프로세스를 새로운 프로세스로 전환
`fork()`로 프로세스를 복사한 뒤 `exec()`로 다른 프로세스로 전환하게 되면, **기존 프로세스 구조를 재활용**할 수 있어 이미 만들어진 <u>PCB, 메모리 영역, 부모-자식 관계</u>를 그대로 사용할 수 있으며, **새로운 코드 영역**만 가져오면 되므로 편리하다.

 <br>

## 스레드
CPU 스케줄러가 CPU에 전달하는 **일 하나**가 스레드이므로, **CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드**가 된다.
>운영체제의 작업 단위는 프로세스, CPU의 작업 단위는 스레드가 된다.

프로세스는 서로 큰 영향을 미치지 않지만, **스레드는 프로세스 내부에서 서로 강하게 연결**된다.
- 멀티태스킹: **프로세스는 서로 독립적**이므로, **하나가 비정상적으로 종료되어도 다른 하나는 정상 작동**한다. 이 때, 서로 독립적인 프로세스는 데이터를 주고받기 위해 <u>프로세스 간 통신(IPC)</u>을 이용한다.
- 멀티스레드: 스레드들은 **변수/파일 등을 공유**하고 **전역 변수/함수 호출 등의 방법으로 스레드끼리 통신**하며 강하게 연결된다.

### 멀티스레드

**멀티스레드**는 정적 영역이 중복되는 <u>멀티태스킹(`fork()`)의 낭비 요소를 제거</u>하기 위해 사용된다. **<u>코드, 데이터 등 자원을 공유</u>하면서 <u>여러 개의 일을 하나의 프로세스 내</u>에서 수행**한다.

![title](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter4/4_01_ThreadDiagram.jpg)

멀티스레드를 사용함으로써,
1. 사용자의 요구에 빨리 응답할 수 있고,
2. 프로세스의 자원을 모든 스레드가 공유하여 작업을 원활하게 할 수 있으며,
3. 불필요한 자원의 중복을 막아 효율성이 향상되었고,
4. 다중 CPU가 멀티스레드를 동시에 처리하여 처리 시간이 단축할 수 있다.

그러나 멀티스레드는 **모든 스레드가 자원을 공유**하기 때문에 **한 스레드에 문제가 생기면 전체 프로세스에 영향**을 미친다.

