## 타입과 추상화

---

### 추상화를 통한 복잡성 극복

<aside>
💡 추상화
1) 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것
2) 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것

</aside>

### 객체지향과 추상화

- 그룹으로 나누어 단순화하기
  → 복잡성을 효과적으로 감소시킴
- 개념
  - 공통점을 기반으로 객체들을 묶기 위한 그릇
  - 개념을 이용하면 객체를 여러 그룹으로 분류(classification)할 수 있음
  - 공통점을 기반으로 객체를 분류할 수 있는 일종의 체, 틀
  - 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 **인스턴스(instance)**라고 함
- 개념의 세 가지 관점
  - 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭
  - 내연(intension): 개념의 완전한 정의, 내연의 의미를 이용해 객체가 개념에 속하는지 여부 확인 가능
  - 외연(extension): 개념에 속하는 모든 객체의 집합(set)
- 객체를 분류하기 위한 틀
  - 객체에 어떤 개념을 적용할 것인지를 결정하는 것은 결정하는 것은 결국 객체들을 개념에 따라 분류하는 것과 동일
  - 적절한 분류 체계는 애플리케이션을 다루는 개발자의 머릿속에 객체를 쉽게 찾고 조작할 수 있는 정신적인 지도 제공
- **분류(classification)**는 추상화를 위한 도구이다
  - 추상화
    1. 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순화
    2. 중요한 부분 강조 위해 불필요한 세부사항 제거해 단순화
  - 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구이다

### 타입

- 타입은 개념이다
  - 공통점을 기반으로 객체들을 묶기 위한 틀
  - 타입의 속하는 객체, 객체에 타입을 적용할 수 있을 때 → 타입의 인스턴스
  - 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것
- 데이터 타입
  - 메모리 안에 저장된 데이터의 종류를 분류하는데 사용하는 메모리 집합에 관한 메타데이터
  - 데이터에 대한 분류는 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지 결정함
- 객체와 타입
  - 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같음
  - 객체가 협력을 위해 어떤 책임을 지녀야 하는 지 결정하는 것이 객체지향 설계의 핵심
  - 객체가 수행하는 행동에 따라 어떤 객체가 어떤 타입에 속하는지 결정됨
  - 객체의 내부적인 표현은 외부로부터 철저하게 감춰지고 내부의 상태를 어떤 방식으로 표현해도 무방
- 행동이 우선이다
  - 객체의 타입을 결정하는 것은 객체의 행동뿐
  - 동일한 행동/동일한 책임/동일한 메시지 수신 ⇒ 동일한 타입
  - 내부 표현 방식이 달라서 같은 메시지를 수신해도 처리 방식은 다를 수 있음
    ⇒ 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력
    ⇒ **다형성**
  - 외부에 행동만을 제공하고 데이터는 행동 뒤로 감추는 것을 지향
    ⇒ **캡슐화**
  - 책임-주도 설계(Responsibility-Driven Design) ↔ 데이터-주도 설계(Data-Driven Design)
  - _객체를 결정하는 것은 행동이며, 데이터는 단지 행동을 따를 뿐_

### 타입의 계층

- 일반화/특수화(generalization/specialization) 관계
  - 타입과 타입 사이의 관계
  - 결국 행동에 관한 것
  - 일반적 타입
    - 특수한 타입이 가진 모든 행동들 중에서 일부 행동만 가지는 타입
    - 적은 행동, 큰 집합
  - 특수한 타입
    - 일반적인 타입이 가진 모든 행동을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입
    - 많은 행동, 작은 집합(부분집합)
- 슈퍼타입과 서브타입
  - 슈퍼타입(Supertype): 일반적인 타입
  - 서브타입(Subtype): 특수한 타입
  - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 ‘**행위적 호환성**’을 만족해야 함
  - 슈퍼타입의 행동은 서브타입에 자동으로 상속됨
  - 관계 표현: 속이 빈 삼각형, 슈퍼타입 상단, 서브타입 하단
- 일반화는 추상화를 위한 도구이다
  - 일반화/특수화 계층은 객체 지향 패러다임에서 추상화의 두 번째 차원을 적절하게 활용하는 대표적인 예

### 정적 모델

- 타입의 목적
  - 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 어렵기 때문
  - 시간에 독립적인 정적인 모습을 다룰 수 있게 함
- 그래서 결국 타입은 추상화다
  ⇒ 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법
- 동적 모델과 정적 모델
  - 동적 모델: 상태가 어떻게 변하고 어떻게 행동하는지
  - 정적 모델: 객체의 상태(동적)가 아닌 객체가 속한 타입의 정적인 모습 표현
- 클래스
  - 객체지향 프로그래밍에서 정적인 모델은 클래스를 이용해 구현됨
  - 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나
  - 코드 재사용하는 용도

<aside>
📌 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동

</aside>

<aside>
📌 동적으로 변하는 객체의 ‘상태’와 상태를 변경하는 ‘행위’

</aside>
